# üß† CONTEXTO DO PROJETO: sia
> Gerado automaticamente em: 2026-02-10 17:28:45

## 1. üå≥ Estrutura de Diret√≥rios
```text
sia
‚îú‚îÄ‚îÄ .agent
‚îÇ   ‚îî‚îÄ‚îÄ rules
‚îÇ       ‚îî‚îÄ‚îÄ execution_rules.md
‚îú‚îÄ‚îÄ app
‚îÇ   ‚îú‚îÄ‚îÄ utils
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dump_code.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ info.py
‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ SKILL.md
‚îî‚îÄ‚îÄ terminal.bat
```

## 2. üì¶ Conte√∫do dos Arquivos (7 arquivos encontrados)

### üìÑ `.agent/rules/execution_rules.md`
```markdown
---
trigger: always_on
---

# Regras de Execu√ß√£o (SIA Project)

Este projeto utiliza Python PORT√ÅTIL (Embedded) em `usr/python`.

## Ambiente
- O ambiente Python √© isolado. A presen√ßa do arquivo `python*._pth` faz com que o `PYTHONPATH` seja **ignorado**.
- O diret√≥rio `app` foi adicionado como raiz de importa√ß√£o no `._pth`.
- Utilize `usr/python/python.exe` para garantir o uso do interpretador correto.

## Como Executar
1. Sempre execute m√≥dulos a partir da raiz do projeto (`c:\srcP\sia`).
2. Utilize o comando `-m` seguido do caminho do m√≥dulo **sem** o prefixo `app`.

   Exemplos:
   - `usr\python\python.exe -m utils.info`
   - `usr\python\python.exe -m main` (se existir `app/main.py`)

3. **Dica:** Se o comando `python` no seu terminal j√° aponta para `usr/python/python.exe` (via `settings.json`), voc√™ pode usar:
   `python -m utils.info`

## Diagn√≥stico
Em caso de erro de importa√ß√£o ou d√∫vida sobre o ambiente, execute:
`usr\python\python.exe -m utils.info`

## Depend√™ncias
Nunca tente instalar pacotes no Python global do sistema. Use o Python em `usr/python`.
```
---

### üìÑ `app/__init__.py`
```python

```
---

### üìÑ `app/utils/__init__.py`
```python

```
---

### üìÑ `app/utils/dump_code.py`
```python
import argparse
import sys
from pathlib import Path
from datetime import datetime
from typing import List, Set

# --- CONFIGURA√á√ÉO (O Contrato) ---
# Ignorar pastas de sistema, git e a pasta do Python Embedded (usr)
IGNORE_DIRS = {".git", "__pycache__", ".venv", "venv", ".idea", ".vscode", "usr", "build", "dist"}

# Extens√µes que queremos ler para dar contexto √† IA
TARGET_EXTENSIONS = {".py", ".md", ".bat", ".json", ".sql"}

def build_tree(root: Path) -> str:
    """
    Gera uma representa√ß√£o visual da √°rvore de diret√≥rios.
    Retorna uma string formatada.
    """
    lines: List[str] = []

    def walk(dir_path: Path, prefix: str = "") -> None:
        try:
            # Filtra e ordena
            entries = sorted([
                e for e in dir_path.iterdir() 
                if e.name not in IGNORE_DIRS
            ], key=lambda x: (x.is_file(), x.name)) # Pastas primeiro
        except PermissionError:
            lines.append(f"{prefix}‚îú‚îÄ‚îÄ [ERRO DE PERMISS√ÉO: {dir_path.name}]")
            return

        for i, entry in enumerate(entries):
            is_last = (i == len(entries) - 1)
            connector = "‚îî‚îÄ‚îÄ " if is_last else "‚îú‚îÄ‚îÄ "
            
            lines.append(f"{prefix}{connector}{entry.name}")

            if entry.is_dir():
                extension = "    " if is_last else "‚îÇ   "
                walk(entry, prefix + extension)

    lines.append(root.name)
    walk(root)
    return "\n".join(lines)

def collect_files(root: Path) -> List[Path]:
    """
    Coleta todos os arquivos que correspondem √†s extens√µes alvo,
    respeitando os diret√≥rios ignorados.
    """
    collected = []
    
    # rglob('*') pega tudo, depois filtramos manualmente para respeitar o IGNORE_DIRS
    # Isso √© mais seguro que rglob('*.py') pois evita entrar em 'usr'
    for path in root.rglob('*'):
        if path.is_file() and path.suffix.lower() in TARGET_EXTENSIONS:
            # Verifica se alguma parte do caminho est√° na lista negra
            if not any(part in IGNORE_DIRS for part in path.parts):
                collected.append(path)
                
    return sorted(collected)

def make_markdown(root: Path) -> str:
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    parts = []
    
    # Cabe√ßalho
    parts.append(f"# üß† CONTEXTO DO PROJETO: {root.name}")
    parts.append(f"> Gerado automaticamente em: {now}")
    parts.append("")
    
    # 1. Estrutura Visual
    parts.append("## 1. üå≥ Estrutura de Diret√≥rios")
    parts.append("```text")
    parts.append(build_tree(root))
    parts.append("```")
    parts.append("")

    # 2. Conte√∫do dos Arquivos
    files = collect_files(root)
    parts.append(f"## 2. üì¶ Conte√∫do dos Arquivos ({len(files)} arquivos encontrados)")
    parts.append("")

    for file_path in files:
        rel_path = file_path.relative_to(root).as_posix()
        ext = file_path.suffix.lower().replace(".", "")
        
        # Mapeamento para syntax highlighting do markdown
        lang_map = {
            "py": "python",
            "md": "markdown",
            "bat": "batch",
            "json": "json",
            "sql": "sql"
        }
        lang = lang_map.get(ext, "text")

        parts.append(f"### üìÑ `{rel_path}`")
        parts.append(f"```{lang}")
        
        try:
            # Tenta ler utf-8, se falhar tenta latin-1 (comum em Windows/Bat antigos)
            try:
                content = file_path.read_text(encoding="utf-8")
            except UnicodeDecodeError:
                content = file_path.read_text(encoding="latin-1")
                
            parts.append(content.strip())
        except Exception as e:
            parts.append(f"[ERRO AO LER ARQUIVO: {e}]")
            
        parts.append("```")
        parts.append("---")
        parts.append("")

    return "\n".join(parts)

def main():
    # 1. Configura√ß√£o do CLI (Interface do Contrato)
    parser = argparse.ArgumentParser(
        description="[Microapp Utilit√°rio] Gera dump de c√≥digo para contexto de IA."
    )
    parser.add_argument("--root", required=True, help="Pasta raiz do projeto para an√°lise")
    parser.add_argument("--dst", required=True, help="Caminho do arquivo Markdown de sa√≠da")
    
    args = parser.parse_args()
    
    root_path = Path(args.root).resolve()
    dst_path = Path(args.dst).resolve()

    print(f"[INFO] Iniciando dump de: {root_path}")
    print(f"[INFO] Destino: {dst_path}")

    # 2. Valida√ß√£o
    if not root_path.exists():
        print(f"[ERRO] Diret√≥rio raiz n√£o encontrado: {root_path}")
        sys.exit(1)

    try:
        # 3. Processamento (Core)
        full_markdown = make_markdown(root_path)
        
        # 4. Sa√≠da (Persist√™ncia)
        dst_path.write_text(full_markdown, encoding="utf-8")
        
        print(f"[SUCESSO] Arquivo gerado com sucesso. Tamanho: {len(full_markdown)/1024:.2f} KB")
        sys.exit(0) # C√≥digo de sucesso para o Maestro

    except Exception as e:
        print(f"[FATAL] Ocorreu um erro n√£o tratado: {e}")
        sys.exit(1) # C√≥digo de erro para o Maestro

if __name__ == "__main__":
    main()
```
---

### üìÑ `app/utils/info.py`
```python
"""
[DIAGN√ìSTICO] Ambiente Python Embedded (Windows) + caminhos de importa√ß√£o

Este utilit√°rio existe para explicar *por que* o comando `python -m ...` √†s vezes
n√£o encontra seus m√≥dulos em uma instala√ß√£o "embedded/portable" do Python.

Pontos-chave (resumo t√©cnico):

1) Em distribui√ß√µes Python *embedded* no Windows, a presen√ßa de um arquivo
   `pythonXY._pth` ao lado do execut√°vel ativa um modo de "path controlado"
   (equivalente pr√°tico a um modo isolado):
   - `sys.path` passa a ser definido *somente* pelas linhas do `._pth`;
   - vari√°veis de ambiente como `PYTHONPATH` (e, em geral, customiza√ß√µes externas)
     tornam-se in√∫teis para resolver imports ‚Äî e, por isso, n√£o √© recomendado
     depender delas nesse tipo de setup;
   - o carregamento de `site` (e `site-packages`) tamb√©m √© controlado pelo
     pr√≥prio `._pth` (linha `import site`).

2) Para que m√≥dulos do projeto sejam import√°veis "de qualquer lugar", o caminho
   do projeto deve estar no `._pth`. Neste setup, foi inclu√≠da a linha:

       ../../app

   dentro de:
       <pasta-do-python>/python313._pth

   Isso faz com que o diret√≥rio `app` do projeto entre no `sys.path`, permitindo
   executar este m√≥dulo assim, independentemente do diret√≥rio atual:

       python -m utils.info

3) Este script imprime:
   - `sys.executable`
   - `PYTHONHOME` / `PYTHONPATH` (se existirem)
   - conte√∫do do arquivo `python*._pth` (se existir)
   - `sys.path` (equivalente a: `python -c "import sys; print(sys.path)"`)
"""

from __future__ import annotations

import glob
import os
import socket
import subprocess
import sys
from pathlib import Path


# ---------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------
def get_ip() -> str:
    """Tenta obter o IP local 'real' (n√£o 127.0.0.1)."""
    try:
        # Truque para pegar o IP real da rede (n√£o o 127.0.0.1)
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except Exception:
        return "127.0.0.1"


def find_pth_file() -> Path | None:
    """Procura por python*._pth no mesmo diret√≥rio do execut√°vel."""
    base = Path(sys.executable).resolve().parent
    matches = sorted(base.glob("python*._pth"))
    return matches[0] if matches else None


def read_text_safe(p: Path) -> str:
    try:
        return p.read_text(encoding="utf-8", errors="replace")
    except Exception as e:
        return f"[ERRO] N√£o foi poss√≠vel ler {p}: {e}"


def check_pip() -> str:
    """Verifica se pip est√° instalado e funcional (quando aplic√°vel)."""
    base_dir = Path(sys.executable).resolve().parent
    pip_exe = base_dir / "Scripts" / "pip.exe"

    if not pip_exe.exists():
        return "NAO ENCONTRADO (Execute setup_app.bat para instalar)"

    # Se existe, pergunta a vers√£o
    try:
        output = subprocess.check_output(
            [sys.executable, "-m", "pip", "--version"],
            text=True,
            stderr=subprocess.STDOUT,
        )
        # O output √© algo como "pip 24.0 from ...", pegamos a segunda palavra
        version = output.split()[1]
        return f"INSTALADO (v{version})"
    except Exception as e:
        return f"ERRO AO VERIFICAR: {e}"


def env(name: str) -> str:
    return os.environ.get(name, "")


def yn(v: bool) -> str:
    return "SIM" if v else "NAO"


# ---------------------------------------------------------------------
# Output
# ---------------------------------------------------------------------
print("-" * 72)
print(f"PYTHON:      {sys.version.split()[0]}")
print(f"EXECUTAVEL:  {sys.executable}")
print(f"DIRETORIO:   {os.getcwd()}")
print(f"IP LOCAL:    {get_ip()}")
print(f"PIP:         {check_pip()}")
print("-" * 72)

pyhome = env("PYTHONHOME")
pypath = env("PYTHONPATH")
print(f"PYTHONHOME:  {pyhome if pyhome else '(nao definido)'}")
print(f"PYTHONPATH:  {pypath if pypath else '(nao definido)'}")

pth = find_pth_file()
embedded = pth is not None
print(f"EMBEDDED:    {yn(embedded)} (arquivo ._pth {'encontrado' if embedded else 'nao encontrado'})")

if embedded:
    print("-" * 72)
    print(f"ARQUIVO ._pth: {pth}")
    pth_text = read_text_safe(pth)
    print("CONTEUDO:")
    print(pth_text.rstrip())

    # Checagens espec√≠ficas do nosso setup
    expected_entry = "../../app"
    has_entry = expected_entry in pth_text
    has_import_site = "\nimport site" in ("\n" + pth_text.replace("\r\n", "\n"))
    print("-" * 72)
    print(f"Entrou '{expected_entry}' no ._pth? {yn(has_entry)}")
    print(f"'import site' habilitado no ._pth? {yn(has_import_site)}")

    # Explica tecnicamente (curto e objetivo) o porqu√™ do PYTHONPATH ser in√∫til aqui
    # e verifica se, na pr√°tica, ele foi ignorado (n√£o aparecendo em sys.path)
    if pypath:
        ignored = pypath not in sys.path
        print(f"PYTHONPATH aparece em sys.path? {yn(not ignored)}")
        if ignored:
            print("OBS: Neste modo, sys.path √© controlado pelo ._pth; por isso PYTHONPATH tende a ser ignorado.")
else:
    print("OBS: Sem ._pth, sys.path tende a incluir o diret√≥rio atual e pode respeitar PYTHONPATH.")

print("-" * 72)
print("sys.path (equivalente a: python -c \"import sys; print(sys.path)\"):")
for i, p in enumerate(sys.path):
    print(f"  [{i}] {p}")

print("-" * 72)
print("Como executar este m√≥dulo de qualquer lugar (com ../../app no ._pth):")
print("  python -m utils.info")
print("-" * 72)
```
---

### üìÑ `SKILL.md`
```markdown
# SKILL.md - SIA (Sistema de Auditoria SQL Port√°til)

## 1. Arquitetura do Projeto
- **Tipo:** Aplica√ß√£o Desktop Port√°til (Windows).
- **Linguagem:** Python 3.13+ (Embedded Distribution).
- **Estrutura de Pastas:**
  - `/root`: Scripts de inicializa√ß√£o (`terminal.bat`).
  - `/usr`: Bin√°rios e Python Embed (N√ÉO versionado, gerado via `setup_python_embedded.bat`).
  - `/app`: C√≥digo fonte do projeto (MVC).
  - `/data`: Arquivos de dados (JSON, SQLite) manipulados pelo usu√°rio.

## 2. Regras de Ambiente (CR√çTICO)
- **N√ÉO use venv/virtualenv:** O ambiente √© isolado via arquivo `._pth`.
- **Imports:** A pasta `app/` j√° est√° no `sys.path`. Importe m√≥dulos como `import utils.info` ou `from modules.audit import core`.
- **Instala√ß√£o de Libs:** Use sempre `python\python.exe -m pip install ...` via terminal port√°til, ou o script de automa√ß√£o.
- **Paths:** Use caminhos relativos baseados em `os.path.dirname(__file__)` para portabilidade total.

## 3. Padr√µes de C√≥digo
- **Type Hinting:** Obrigat√≥rio em todas as assinaturas de fun√ß√£o (Python 3.13).
- **Tratamento de Erros:** Logs devem ser salvos em arquivo local, pois o usu√°rio final pode n√£o ver o console.
- **UI:** (Definir aqui se usar√° TUI, Flet, TKinter ou Webview).
```
---

### üìÑ `terminal.bat`
```batch
@echo off
title Terminal SIA - Python Portable

REM --- Carrega o Ambiente ---
call usr\init_env.bat
if %errorlevel% neq 0 (
    pause
    exit /b
)

REM --- Interface Visual ---
cls
echo ==========================================================
echo        TERMINAL DO MICROAPP PYTHON (EMBEDDED)
echo ==========================================================
echo.
echo  [AMBIENTE CARREGADO]
echo.
echo  Pasta App:  %CD%\app
echo  Python:     %PYTHONHOME%\python.exe
echo.
echo  Comandos disponiveis:
echo    test   - Roda o diagnostico (utils.info)
echo    clean  - Limpa caches (__pycache__)
echo    sia    - (Futuro) Executara o sistema principal
echo.
echo ========================================================
echo.

REM Executa o teste inicial automaticamente
python -m utils.info

REM Mant√©m o terminal aberto para intera√ß√£o
cmd /k
```
---
